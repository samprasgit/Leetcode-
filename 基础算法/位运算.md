# 基础知识



**位运算（Bit Operation）**：在计算机内部，数是以「二进制（Binary）」的形式来进行存储。位运算就是直接对数的二进制进行计算操作，在程序中使用位运算进行操作，会大大提高程序的性能。

**位运算基础操作**

| 运算符 | 描述           | 规则                                                         |
| ------ | -------------- | ------------------------------------------------------------ |
| `|`    | 按位或运算符   | 只要对应的两个二进位有一个为 1 时，结果位就为 1。            |
| `&`    | 按位与运算符   | 只有对应的两个二进位都为 1 时，结果位才为 1。                |
| `<<`   | 左移运算符     | 将二进制数的各个二进位全部左移若干位。`<<` 右侧数字指定了移动位数，高位丢弃，低位补 0。 |
| `>>`   | 右移运算符     | 对二进制数的各个二进位全部右移若干位。`>>` 右侧数字指定了移动位数，低位丢弃，高位补 0。 |
| `^`    | 按位异或运算符 | 对应的两个二进位相异时，结果位为 1，二进位相同时则结果位为 0。 |
| `~`    | 取反运算符     | 对二进制数的每个二进位取反，使数字 1 变为 0，0 变为 1。      |

**位运算常用操作**

- 判断整数奇偶

一个整数，只要是偶数，其对应二进制数的末尾一定为 0；只要是奇数，其对应二进制数的末尾一定为 1。所以，我们通过与 1 进行按位与运算，即可判断某个数是奇数还是偶数。

1. `(x & 1) == 0` 为偶数。
2. `(x & 1) == 1` 为奇数。

-  二进制数选取指定位

如果我们想要从一个二进制数 � 中取出某几位，使取出位置上的二进位保留原值，其余位置为 0，则可以使用另一个二进制数 �，使该二进制数上对应取出位置为 1，其余位置为 0。然后令两个数进行按位与运算（`X & Y`），即可得到想要的数。

举个例子，比如我们要取二进制数 �=01101010(2) 的末尾 4 位，则只需将 �=01101010(2) 与 �=00001111(2) (末尾 4 位为 1，其余位为 0) 进行按位与运算，即 `01101010 & 00001111 == 00001010`。其结果 00001010 就是我们想要的数（即二进制数 01101010(2) 的末尾 4 位）。

- 将指定位设置为 1

如果我们想要把一个二进制数 � 中的某几位设置为 1，其余位置保留原值，则可以使用另一个二进制数 �，使得该二进制上对应选取位置为 1，其余位置为 0。然后令两个数进行按位或运算（`X | Y`），即可得到想要的数。

举个例子，比如我们想要将二进制数 �=01101010(2) 的末尾 4 位设置为 1，其余位置保留原值，则只需将 �=01101010(2) 与 �=00001111(2)（末尾 4 位为 1，其余位为 0）进行按位或运算，即 `01101010 | 00001111 = 01101111`。其结果 01101111 就是我们想要的数（即将二进制数 01101010(2) 的末尾 4 位设置为 1，其余位置保留原值）。

- 反转指定位

如果我们想要把一个二进制数 � 的某几位进行反转，则可以使用另一个二进制数 �，使得该二进制上对应选取位置为 1，其余位置为 0。然后令两个数进行按位异或运算（`X ^ Y`），即可得到想要的数。

举个例子，比如想要将二进制数 �=01101010(2) 的末尾 4 位进行反转，则只需将 �=01101010(2) 与 �=00001111(2)（末尾 4 位为 1，其余位为 0）进行按位异或运算，即 `01101010 ^ 00001111 = 01100101`。其结果 01100101 就是我们想要的数（即将二进制数 �=01101010(2) 的末尾 4 位进行反转）。

- 交换两个数

通过按位异或运算可以实现交换两个数的目的（只能用于交换两个整数）。

```python
a, b = 10, 20
a ^= b
b ^= a
a ^= b
print(a, b)Copy to clipboardErrorCopied
```

- 将二进制最右侧为 1 的二进位改为 0

如果我们想要将一个二进制数 � 最右侧为 1 的二进制位改为 0，则只需通过 `X & (X - 1)` 的操作即可完成。

比如 �=01101100(2)，�−1=01101011(2)，则 `X & (X - 1) == 01101100 & 01101011 == 01101000`，结果为 01101000(2)（即将 � 最右侧为 1 的二进制为改为 0）。

- 计算二进制中二进位为 1 的个数

从 3.1.6 中得知，通过 `X & (X - 1)` 我们可以将二进制 � 最右侧为 1 的二进制位改为 0，那么如果我们不断通过 `X & (X - 1)` 操作，最终将二进制 � 变为 0，并统计执行次数，则可以得到二进制中二进位为 1 的个数。

具体代码如下：

```python
class Solution:
    def hammingWeight(self, n: int) -> int:
        cnt = 0
        while n:
            n = n & (n - 1)
            cnt += 1
        return cntCopy to clipboardErrorCopied
```

- 判断某数是否为 2 的幂次方

通过判断 `X & (X - 1) == 0` 是否成立，即可判断 � 是否为 2 的幂次方。

这是因为：

1. 凡是 2 的幂次方，其二进制数的某一高位为 1，并且仅此高位为 1，其余位都为 0。比如：4(10)=00000100(2)、8(10)=00001000(2)。
2. 不是 2 的幂次方，其二进制数存在多个值为 1 的位。比如：510=00000101(2)、610=00000110(2)。

接下来我们使用 `X & (X - 1)` 操作，将原数对应二进制数最右侧为 1 的二进位改为 0 之后，得到新值：

1. 如果原数是 2 的幂次方，则通过 `X & (X - 1)` 操作之后，新值所有位都为 0，值为 0。
2. 如果该数不是 2 的幂次方，则通过 `X & (X - 1)` 操作之后，新值仍存在不为 0 的位，值肯定不为 0。

所以我们可以通过是否为 0 即可判断该数是否为 2 的幂次方。

**位运算常用操作总结**

![image-20231225013504366](image-20231225013504366.png)

#  LeetCode应用

## 136. 只出现一次的数字

[只出现一次的数字](https://leetcode-cn.com/problems/single-number/description/)

> 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

```
0010 0100
^
0010 0100
=
0000 0000
```

由以上可得知，相同数字做^异或运算，会得到0。

```python
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        return reduce(lambda x, y: x ^ y, nums)

```



## 137. 只出现一次的数字 II

[只出现一次的数字 II](https://leetcode-cn.com/problems/single-number-ii/description/)

> 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。

1. 对每个整数以32位表示，分别统计每一位上1的个数，最后该位数上的和对3取余数；
2. 如果余数不为0，则说明该位上只出现一次的元素，在该位上有1;
3. 通过移位操作和1做位与运算，则可求得当前元素在该位是否有1。

```
class Solution(object):
    def singleNumber(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        # 参考https://shenjie1993.gitbooks.io/leetcode-python/137%20Single%20Number%20II.html
        res = 0
        # 将数值映射到32位的bit位上
        for i in range(32):
            sumone = 0
            tmp = 0
            for j in range(len(nums)):
                # 统计每个bit位上值为1出现的次数
                # x & 1 判断x的最后一位是否为1，为1则结果是1 不为1则结果是0
                # 每一轮统计要将数右移i位，去查看这个位上值是否为1
                sumone += (nums[j] >> i) & 1
            # sumone如果是3的倍数这说明这个位上出现了3次元素
            # 当余数不为0，则说明这个位上只出现了1次的数据在这个位置上有1
            # 然后将这个1左移i位就可以将只出现一次的那个数在这个位上取1
            # 按位或操作只要有一个为1，则结果为1
            tmp = sumone % 3
            # 处理负数的情况
            if i == 31 and tmp:
                res -= 1 << 31
            else:
                res |= tmp << i
        return res

if __name__ == '__main__':
    s = Solution()
    nums = [1, 1, 1, 2, 3, 3, 3]
    print(s.singleNumber(nums))
    
输出：
2
```

## 260. 只出现一次的数字 III

参见[只出现一次的数字 III](https://leetcode-cn.com/problems/single-number-iii/description/)

> 给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。

```
class Solution(object):
    def singleNumber(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        # 参考https://blog.csdn.net/smile_watermelon/article/details/47750249
        # 先对数组中的每个数字进行异或运算，以为有相同的数字，
        # 故异或运算后会抵消，剩下的就是两个只出现一次的数字异或运算的结果
        # 假设两个出现次数为1的数分别为a b
        # z = a ^ b
        z = 0
        for i in nums:
            z ^= i
        # 找到z中第一个位1的二进制位
        # 因为z中二进制位1的位置说明a,b中一个位0 一个位1
        index = 0
        while z & 1 == 0:
            z >>= 1
            index += 1

        a = 0
        b = 0
        for i in nums:
            # 然后比较这个数字的二进制位在index这个位上是否为1，将数字分开
            if (i >> index) & 1:
                a ^= i
            else:
                b ^= i
        return [a,b]

```

# 参考

[LeetCode算法笔记](https://datawhalechina.github.io/leetcode-notes/#/ch04/04.05/04.05.01-Bit-Operation)