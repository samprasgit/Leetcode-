回溯使用的场景：
回溯法非常适合由多个步骤组成的问题，并且每个步骤都有多个选项，当我们在某一步选择了其中一个选项时，就进入下一步，然后又面临新的选项。我们就这样重复选择着，直至到达最后的状态。

一般画树状图表示

做回溯的题步骤：【树的深度遍历过程】

- 画图，观察元素是否有重复，如有重复则需要剪枝，思考如何剪枝
- 回溯三要素：路径、选择列表、结束条件
- 按照此代码模板，写出代码。



算法框架
废话不多说，直接上回溯算法框架。解决一个回溯问题，实际上就是一个决策树的遍历过程。你只需要思考 3 个问题：

1、路径：也就是已经做出的选择。

2、选择列表：也就是你当前可以做的选择。

3、结束条件：也就是到达决策树底层，无法再做选择的条件。

代码方面，回溯算法的框架：

    res = []    # 存放所欲符合条件结果的集合
    path = []   # 存放当前符合条件的结果
    def backtracking(nums):             # nums 为选择元素列表
        if 遇到边界条件:                  # 说明找到了一组符合条件的结果
            res.append(path[:])         # 将当前符合条件的结果放入集合中
            return
    
        for i in range(len(nums)):      # 枚举可选元素列表
            path.append(nums[i])        # 选择元素
            backtracking(nums)          # 递归搜索
            path.pop()                  # 撤销选择
    
    backtracking(nums)
    
其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」，特别简单。

剪枝方法：

- 全排列里面的剪枝，只需要考虑后面的元素和第一个元素相同的情况，则continue。但是要注意是要保证同层不同和上下层相同（i > start），详见leetcode40.总结
- 对于全排列题不适合用mark，mark用在矩阵中元素只访问一次的情况下如访问矩阵里的坐标或者字母题。

