#枚举
## 1 枚举算法
### 1.1 枚举算法简介
>**枚举算法（Enumeration Algorithm）**：也称为穷举算法，指的是按照问题本身的性质，一一列举出该问题所有可能的解，并在逐一列举的过程中，将它们逐一与目标状态进行比较以得出满足问题要求的解。在列举的过程中，既不能遗漏也不能重复。

优点：
1. 多数情况下容易编程实现，也容易调试。
2. 建立在考察大量状态、甚至是穷举所有状态的基础上，所以算法的正确性比较容易证明。
缺点：
1. 在问题规模变大时，其效率一般是比较低的
### 1.2 枚举算法的解题思路
枚举算法是设计最简单、最基本的搜索算法。是我们在遇到问题时，最应该优先考虑的算法。
因为其实现足够简单，所以在遇到问题时，我们往往可以先通过枚举算法尝试解决问题，然后在此基础上，再去考虑其他优化方法和解题思路。

采用枚举算法解题的一般思路如下：

1. 确定枚举对象、枚举范围和判断条件，并判断条件设立的正确性。
2. 一一枚举可能的情况，并验证是否是问题的解。
3. 考虑提高枚举算法的效率。

我们可以从下面几个方面考虑提高算法的效率：

1. 抓住问题状态的本质，尽可能缩小问题状态空间的大小。
2. 加强约束条件，缩小枚举范围。
3. 根据某些问题特有的性质，例如对称性等，避免对本质相同的状态重复求解。


### 1.3 枚举算法的应用
1. 百钱买百鸡问题
公鸡一只五块钱，母鸡一只三块钱，小鸡三只一块钱。现在我们用 100 块钱买了 100 只鸡，问公鸡、母鸡、小鸡各买了多少只？
下面我们根据算法的一般思路来解决一下这道题。

1. 确定枚举对象、枚举范围和判断条件，并判断条件设立的正确性。
    
    1. 确定枚举对象：枚举对象为公鸡、母鸡、小鸡的只数，那么我们可以用变量 $x$ 、$y$、$z$ 分别来代表公鸡、母鸡、小鸡的只数。
    2. 确定枚举范围：因为总共买了 100 只鸡，所以 $0<=x,y,z<=100$，则 $x$ 、$y$、$z$  的枚举范围为 $[0,100]$。
    3. 确定判断条件：根据题意，我们可以列出两个方程式：$5 \times x + 3\times y + \frac{z}{3}=100,x+y+z=100$。在枚举  $x$ 、$y$、$z$  的过程中，我们可以根据这两个方程式来判断是否当前状态是否满足题意。
2. 一一枚举可能的情况，并验证是否是问题的解。
	1. 根据枚举对象、枚举范围和判断条件，我们可以顺利写出对应的代码
```Python

    def buyChicken():
        for x in range(101):
            for y in range(101):
                for z in range(101):
                    if z % 3 == 0 and 5 * x + 3 * y + z // 3 == 100 and x + y + z == 100:
                        print("公鸡 %s 只，母鸡 %s 只，小鸡 %s 只" % (x, y, z))
```
考虑提高枚举算法的效率
1. 在上面的代码中，我们枚举了  $x$ 、$y$、$z$ ，但其实根据方程式 $x+y+z=100$，得知：$z$ $ 可以通过 $z=100-x-y$ 而得到，这样我们就不用再枚举 $z$ 了。
2. 在上面的代码中，对 $x,y$ 的枚举范围是 $[0,100]$，但其实如果所有钱用来买公鸡，最多只能买 20 只，同理，全用来买母鸡，最多只能买 33 只。所以对 $x$ 的枚举范围可改为 [0,20]，$y$ 的枚举范围可改为 [0,33]。
```python
def buyChicken(): 
	for x in range(21):
		for y in range(34): 
			z = 100 - x - y 
			if z % 3 == 0 and 5 * x + 3 * y + z // 3 == 100: 
				print("公鸡 %s 只，母鸡 %s 只，小鸡 %s 只" % (x, y, z))
```

### 1.4 枚举算法在 LeetCode 中的应用

- [1. 两数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/two-sum/)
1. 题目大意
**描述**：给定一个整数数组 $nums$ 和一个整数目标值 $target$。

**要求**：在该数组中找出和为 $target$ 的两个整数，并输出这两个整数的下标。可以按任意顺序返回答案。
- 示例 1：

```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```
- 示例 2：
```
输入：nums = [3,2,4], target = 6
输出：[1,2]
```
1. 解题思路 1   - 枚举法
	1. 1. 使用两重循环枚举数组中每一个数 $nums[i]$, $nums[j]$，判断所有的 $nums[i]+nums[j]$ 是否等于 $target$。
	2. 1. 如果出现 $nums[i]+nums[j]=target$，则说明数组中存在和为 $target$ 的两个整数，将两个整数的下标 $i，j$ 输出即可。
```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        for i in range(len(nums)):
            for j in range(i + 1, len(nums)):
                if i != j and nums[i] + nums[j] == target:
                    return [i, j]
        return []
```

- [204. 计数质数 - 力扣（LeetCode）](https://leetcode.cn/problems/count-primes/)
1. 解题思路-枚举算法
```Python
class Solution:

	def isPrime(self, x):

		for i in range(2, int(pow(x, 0.5)) + 1):

			if x % i == 0:

				return False

		return True

  

	def countPrimes(self, n: int) -> int:

		cnt = 0

		for x in range(2, n):

			if self.isPrime(x):

				cnt += 1

		return cnt
```

- [1925. 统计平方和三元组的数目 - 力扣（LeetCode）](https://leetcode.cn/problems/count-square-sum-triples/)
1. 解题思路枚举法
```python 
class Solution:
    def countTriples(self, n: int) -> int:
        cnt = 0
        for a in range(1, n + 1):
            for b in range(1, n + 1):
                c = int(sqrt(a * a + b * b + 1))
                if c <= n and a * a + b * b == c * c:
                    cnt += 1
        return cnt
```



## 参考
[LeetCode算法笔记-枚举算法](https://datawhalechina.github.io/leetcode-notes/#/ch04/04.01/04.01.01-Enumeration-Algorithm?id=_22-%e6%9e%9a%e4%b8%be%e7%ae%97%e6%b3%95%e7%9a%84%e7%ae%80%e5%8d%95%e5%ba%94%e7%94%a8)

